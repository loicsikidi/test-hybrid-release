package main

import (
	"encoding/pem"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/loicsikidi/test-hybrid-release/internal/git"
	"github.com/loicsikidi/test-hybrid-release/internal/version"
	"go.step.sm/crypto/minica"
	"go.step.sm/crypto/pemutil"
)

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Usage: awesomecli [version|generate]")
		os.Exit(1)
	}

	generateCmd := flag.NewFlagSet("generate", flag.ExitOnError)
	output := generateCmd.String("output", "", "Output file for the generated bundle (default: stdout)")

	switch subcmd := os.Args[1]; subcmd {
	case "version":
		fmt.Println(version.Get())
	case "generate":
		_ = generateCmd.Parse(os.Args[2:])
		if err := createBundle(*output); err != nil {
			fmt.Fprintf(os.Stderr, "Error creating bundle: %v\n", err)
			os.Exit(1)
		}
		if *output == "" {
			fmt.Fprintln(os.Stderr, "Bundle generated successfully to stdout ðŸš€")
		} else {
			fmt.Fprintf(os.Stderr, "Bundle generated successfully to %s ðŸš€\n", *output)
		}
	default:
		fmt.Fprintf(os.Stderr, "Unknown subcommand '%s'. Expected 'version' or 'generate'\n", subcmd)
		os.Exit(1)
	}
}

func createBundle(output string) error {
	date, commit, err := resolveGitMetadata()
	if err != nil {
		return fmt.Errorf("failed to resolve git metadata: %w", err)
	}

	pemBlocks := getPemBlocks()

	var bundle strings.Builder
	bundle.WriteString(buildBundleHeader(output, date, commit))
	bundle.WriteString(strings.Join(pemBlocks, "\n"))
	content := []byte(bundle.String())

	if output == "" {
		_, err = os.Stdout.Write(content)
		return err
	}
	return os.WriteFile(output, content, 0644)
}

func getPemBlocks() []string {
	localCA, err := minica.New()
	if err != nil {
		panic(err)
	}
	block, err := pemutil.Serialize(localCA.Root)
	if err != nil {
		panic(err)
	}

	b := pem.EncodeToMemory(block)
	return []string{string(b)}
}

// resolveGitMetadata auto-detects date and commit from git repository.
// It assumes this function is only called when --date and --commit flags are not provided.
// Returns date (from git tag in YYYY-MM-DD format) and commit hash.
func resolveGitMetadata() (string, string, error) {
	info, err := git.GetInfo(".")
	if err != nil {
		return "", "", fmt.Errorf("failed to get git info (use --date and --commit flags to specify manually): %w", err)
	}

	// Use tag as date (must be in YYYY-MM-DD format)
	if info.Tag == "" {
		return "", "", fmt.Errorf("no git tag found for current commit (tag is required in YYYY-MM-DD format, or use --date and --commit flags)")
	}
	if err := validateDate(info.Tag); err != nil {
		return "", "", fmt.Errorf("git tag %q is not in YYYY-MM-DD format (use --date and --commit flags to specify manually): %w", info.Tag, err)
	}
	if err := validateCommit(info.Commit); err != nil {
		return "", "", fmt.Errorf("git commit %q is not a valid commit hash (use --date and --commit flags to specify manually): %w", info.Commit, err)
	}

	return info.Tag, info.Commit, nil
}

// validateDate checks if the date is in YYYY-MM-DD format.
func validateDate(d string) error {
	dateRegex := regexp.MustCompile(`^\d{4}-\d{2}-\d{2}$`)
	if !dateRegex.MatchString(d) {
		return fmt.Errorf("date must be in YYYY-MM-DD format, got: %s", d)
	}
	return nil
}

// validateCommit checks if the commit is a valid 40-character hex string.
func validateCommit(c string) error {
	commitRegex := regexp.MustCompile(`^[0-9a-f]{40}$`)
	if !commitRegex.MatchString(c) {
		return fmt.Errorf("commit must be a 40-character hex string, got: %s", c)
	}
	return nil
}

func buildBundleHeader(outputPath, date, commit string) string {
	var header strings.Builder
	header.WriteString("##\n")

	if outputPath != "" {
		filename := filepath.Base(outputPath)
		header.WriteString(fmt.Sprintf("## %s\n", filename))
	} else {
		header.WriteString("## tpm-ca-certificates.pem\n")
	}

	header.WriteString("##\n")

	if date != "" {
		header.WriteString(fmt.Sprintf("## Date: %s\n", date))
	}
	if commit != "" {
		header.WriteString(fmt.Sprintf("## Commit: %s\n", commit))
	}

	header.WriteString("##\n")
	header.WriteString("## This file has been auto-generated by tpmtb (TPM Trust Bundle)\n")
	header.WriteString("## and contains a list of verified TPM Root Endorsement Certificates.\n")
	header.WriteString("##\n")
	header.WriteString("\n")
	return header.String()
}
